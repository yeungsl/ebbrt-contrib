//          Copyright Boston University SESA Group 2013 - 2016.
//
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
#ifndef EBBRT_ZKCOUNTER_H_
#define EBBRT_ZKCOUNTER_H_

#include "MulticoreEbb.h"
#include <ebbrt/GlobalIdMap.h>
#include <ebbrt/LocalIdMap.h>
#include "StaticEbbIds.h"
#include <ebbrt/Messenger.h>
#include <ebbrt/Message.h>
#include <string>

namespace ebbrt {

class Counter;

 class CounterRoot : public ebbrt::MulticoreEbbRoot<CounterRoot, Counter>{
   using MulticoreEbbRoot<CounterRoot, Counter>::MulticoreEbbRoot;
private:
  std::mutex lock_;
  std::vector<ebbrt::Messenger::NetworkId> nodelist;
  int init_ = 0;
public:
 CounterRoot(ebbrt::EbbId id)
   : MulticoreEbbRoot<CounterRoot, Counter>(id),  nodelist{} {}
  uint64_t Get();
  void addTo(ebbrt::Messenger::NetworkId nid){
    {
      std::lock_guard<std::mutex> guard(lock_);
      if (std::find(nodelist.begin(), nodelist.end(), nid) == nodelist.end()){
	nodelist.push_back(nid);
      }
    }
    return;
  }
  ebbrt::Messenger::NetworkId nlist(int i){ return nodelist[i]; }
  int size(){ return int(nodelist.size()); }
  std::unordered_map<uint32_t, ebbrt::Promise<int>> promise_map_;
};

class Counter : public ebbrt::MulticoreEbb<Counter, CounterRoot>, public ebbrt::Messagable<Counter>{
  using MulticoreEbb<Counter, CounterRoot>::MulticoreEbb;

private:
  std::mutex lock_;
  ebbrt::Future<int> ConsistentJoin( ebbrt::Messenger::NetworkId nid, ebbrt::CounterRoot * root );
  std::vector<ebbrt::Future<int>> Gather();

  uint64_t count_ = 0;
public:
  // implicit use of template constructors

  Counter(ebbrt::EbbId id)
    : MulticoreEbb<Counter, CounterRoot>(id), ebbrt::Messagable<Counter>(id){}
  static ebbrt::EbbRef<Counter>
  Create(int init, ebbrt::EbbId id = kNcCounterEbbId){
    LocalIdMap::Accessor accessor;
    auto created = local_id_map->Insert(accessor, id);
    if(!created){
      ebbrt::kabort();
    }
    auto root = new CounterRoot(id);
    accessor->second = root;
    // Root created, but Counter rep not created yet
    // so making the home node to insert network id into global id map
    // and back end could also grab the network id from the global id map
    // assuming everyting the home node get allocated first
#ifdef __ebbrt__

    //trying to get the network id of home node

    auto f = ebbrt::global_id_map->Get(id);
    auto net_if = f.Block().Get();
    auto nid = ebbrt::Messenger::NetworkId(net_if);
    ebbrt::kprintf("network id is %s\n", nid.ToString().c_str());    
    root -> addTo(nid);
    auto c = new ebbrt::Counter(id);
    auto f_c = c->ConsistentJoin(nid, root);
    f_c.Then([&c](ebbrt::Future<int> inner){
	assert(inner.Get() == 0);

      });

    /*
    ebbrt::EventManager::EventContext context;
    auto f = ebbrt::global_id_map->Get(id);
    ebbrt::Counter* p;
    f.Then([&f, &context, &p, &root, id](ebbrt::Future<std::string> inner) {
	auto nid = ebbrt::Messenger::NetworkId(inner.Get());
	p = new ebbrt::Counter(id);
	root->addTo(nid);
	auto f_c = p->ConsistentJoin(nid, root);
	f_c.Then([&context](ebbrt::Future<int> inner){
	    assert(inner.Get() == 0);
	    ebbrt::event_manager->ActivateContext(std::move(context));    
	  });
      });
    ebbrt::event_manager->SaveContext(context);
    */

#else
    //setting the network id of home node
    ebbrt::kprintf("home node id is %s\n", ebbrt::messenger->LocalNetworkId().ToString().c_str());
    ebbrt::global_id_map->Set(id, ebbrt::messenger->LocalNetworkId().ToBytes());
#endif
    return ebbrt::EbbRef<Counter>(id);
  }
  void ReceiveMessage(ebbrt::Messenger::NetworkId nid, std::unique_ptr<ebbrt::IOBuf>&& buffer);  
  void Up();
  void Down();
  uint64_t GetLocal();
  uint64_t GetRoot();
  void ping();
  ebbrt::Messenger::NetworkId nlist(int i){ return root_->nlist(i); }
  int size(){ return root_->size(); }
  void addTo(ebbrt::Messenger::NetworkId nid){  root_ -> addTo(nid);  }
  int GlobalVal();
};


};     // end namespace
#endif // EBBRT_ZKGLOBALIDMAP_H_
